---
title: "Auto-Tracking Progress: How AI Detects Achievements Without Manual Input"
description: "Explore how agentic functions automatically track founder progress, eliminating manual logging while powering gamification in 2026."
date: "2026-03-19"
author: "Startup Games Team"
tags: ["automation", "ai", "agentic-functions", "tracking"]
---

# Auto-Tracking Progress: How AI Detects Achievements Without Manual Input

Manual tracking killed every gamification attempt before 2026. Founders were too busy building to log achievements, update progress bars, or claim rewards. The friction destroyed the magic.

Agentic functions changed everything. Now, AI automatically detects every achievement, milestone, and progress marker—without founders lifting a finger.

## The Manual Tracking Problem

Previous gamification systems required founders to:
- Log every deployment manually
- Track customer acquisitions
- Update quest progress
- Claim achievements
- Record metrics

This created fatal friction:
- **Forgetting**: "I shipped 3 features yesterday but forgot to log them"
- **Laziness**: "I'll update it later" (never does)
- **Gaming**: Logging fake progress to climb leaderboards
- **Frustration**: "I have to maintain another system?"

Result: 90%+ abandonment rate within first week.

## The Agentic Solution

Agentic functions monitor everything automatically:

```typescript
// Continuous monitoring agent
export const trackFounderActivity = agenticFunction({
  schedule: 'every 5 minutes',
  async execute() {
    const activeFounders = await getActiveFounders();

    for (const founder of activeFounders) {
      // Check all connected data sources
      const activity = await detectActivity({
        founderId: founder.id,
        sources: [
          'git-commits',
          'deployments',
          'customer-data',
          'revenue-events',
          'content-published',
          'community-interactions'
        ],
        since: founder.lastChecked
      });

      // Process each activity
      for (const event of activity) {
        await processFounderEvent({
          founderId: founder.id,
          event,
          timestamp: event.timestamp
        });
      }

      // Update last checked timestamp
      await updateFounder(founder.id, {
        lastChecked: Date.now()
      });
    }
  }
});
```

## Integration Architecture

### Startup-Builder Integration

Auto-track development activity:

```typescript
// Webhook from startup-builder on every deployment
export const onDeploy = codeFunction({
  input: z.object({
    founderId: z.string(),
    deployment: z.object({
      functionName: z.string(),
      version: z.string(),
      timestamp: z.number(),
      linesOfCode: z.number(),
      testsAdded: z.number(),
      breaking: z.boolean()
    })
  }),
  async execute({ founderId, deployment }) {
    // Award XP for deployment
    await awardXP({
      founderId,
      action: 'deployment',
      amount: calculateDeploymentXP(deployment),
      metadata: deployment
    });

    // Check for achievements
    await checkDeploymentAchievements(founderId, deployment);

    // Update quest progress
    await updateQuestProgress(founderId, 'deployment', deployment);

    // Update streaks
    await recordDailyActivity(founderId, 'deployment');

    // Update leaderboards
    await updateLeaderboardScore(founderId, 'shipping-velocity');

    return { tracked: true };
  }
});

function calculateDeploymentXP(deployment: any): number {
  let baseXP = 10;

  // Bonus for substantial changes
  if (deployment.linesOfCode > 100) baseXP += 20;
  if (deployment.linesOfCode > 500) baseXP += 50;

  // Bonus for tests
  if (deployment.testsAdded > 0) baseXP += deployment.testsAdded * 5;

  // Penalty for breaking changes without proper versioning
  if (deployment.breaking && deployment.version.includes('0.')) {
    baseXP -= 5;
  }

  return Math.max(baseXP, 5); // Minimum 5 XP
}
```

### Sales-Builder Integration

Auto-track business metrics:

```typescript
// Webhook from sales-builder on customer events
export const onCustomerEvent = codeFunction({
  input: z.object({
    founderId: z.string(),
    event: z.object({
      type: z.enum(['signup', 'conversion', 'churn', 'expansion']),
      customerId: z.string(),
      value: z.number().optional(),
      timestamp: z.number()
    })
  }),
  async execute({ founderId, event }) {
    switch (event.type) {
      case 'signup':
        await handleSignup(founderId, event);
        break;
      case 'conversion':
        await handleConversion(founderId, event);
        break;
      case 'expansion':
        await handleExpansion(founderId, event);
        break;
      case 'churn':
        await handleChurn(founderId, event);
        break;
    }

    return { tracked: true };
  }
});

async function handleConversion(founderId: string, event: any) {
  // Award XP based on deal value
  const xp = Math.floor(event.value / 10); // $10 = 1 XP

  await awardXP({
    founderId,
    action: 'customer-conversion',
    amount: xp,
    metadata: event
  });

  // Check for revenue milestones
  const totalRevenue = await getTotalRevenue(founderId);

  if (totalRevenue === event.value) {
    // First dollar!
    await unlockAchievement(founderId, 'first-dollar');
  }

  if (totalRevenue >= 1000 && totalRevenue - event.value < 1000) {
    await unlockAchievement(founderId, 'first-1k');
  }

  // Update quest progress
  await updateQuestProgress(founderId, 'revenue', event);

  // Update leaderboards
  await updateLeaderboardScore(founderId, 'revenue-growth');
}
```

### Git Integration

Track code activity:

```typescript
// GitHub/GitLab webhook handler
export const onGitPush = codeFunction({
  input: z.object({
    founderId: z.string(),
    commits: z.array(z.object({
      hash: z.string(),
      message: z.string(),
      additions: z.number(),
      deletions: z.number(),
      filesChanged: z.number(),
      timestamp: z.number()
    }))
  }),
  async execute({ founderId, commits }) {
    for (const commit of commits) {
      // Award XP for meaningful commits
      const significance = await assessCommitSignificance(commit);

      if (significance.meaningful) {
        await awardXP({
          founderId,
          action: 'git-commit',
          amount: significance.xp,
          metadata: commit
        });
      }

      // Check for streak
      await recordDailyActivity(founderId, 'coding');
    }

    // Check for commit-based achievements
    const totalCommits = await getTotalCommits(founderId);

    if (totalCommits === 1) {
      await unlockAchievement(founderId, 'first-commit');
    }

    if (totalCommits === 100) {
      await unlockAchievement(founderId, 'century-committer');
    }

    return { tracked: true };
  }
});

async function assessCommitSignificance(commit: any) {
  // Use AI to determine if commit is meaningful
  const analysis = await analyzeCommit({
    message: commit.message,
    additions: commit.additions,
    deletions: commit.deletions,
    filesChanged: commit.filesChanged
  });

  // Filter out trivial commits
  const meaningful =
    !analysis.isTrivial &&
    !analysis.isTypoFix &&
    (commit.additions + commit.deletions > 10);

  const xp = meaningful ?
    Math.min(Math.floor((commit.additions + commit.deletions) / 10), 50) :
    0;

  return { meaningful, xp, analysis };
}
```

## AI-Powered Achievement Detection

Some achievements require intelligent interpretation:

```typescript
export const detectComplexAchievements = agenticFunction({
  schedule: 'hourly',
  async execute() {
    const founders = await getAllActiveFounders();

    for (const founder of founders) {
      // Get recent activity
      const activity = await getRecentActivity(founder.id, 24); // Last 24 hours

      // Use AI to detect achievement patterns
      const achievements = await detectAchievementPatterns({
        founderId: founder.id,
        activity,
        historicalData: founder.metrics,
        achievementsEarned: founder.achievements
      });

      for (const achievement of achievements) {
        if (!founder.achievements.includes(achievement.id)) {
          await unlockAchievement(founder.id, achievement.id);
        }
      }
    }
  }
});

// AI analysis of activity patterns
async function detectAchievementPatterns(data: any) {
  const achievements = [];

  // "Night Owl": Multiple deployments between midnight-5am
  const nightCommits = data.activity.filter(
    a => a.type === 'commit' &&
    new Date(a.timestamp).getHours() >= 0 &&
    new Date(a.timestamp).getHours() < 5
  );

  if (nightCommits.length >= 5) {
    achievements.push({ id: 'night-owl', confidence: 0.95 });
  }

  // "Customer Obsessed": 10+ customer conversations in a week
  const customerCalls = data.activity.filter(
    a => a.type === 'customer-call'
  );

  if (customerCalls.length >= 10) {
    achievements.push({ id: 'customer-obsessed', confidence: 1.0 });
  }

  // "Pivot Master": Major change in product direction
  const pivotDetected = await detectPivot(data.historicalData);

  if (pivotDetected.isPivot && pivotDetected.successful) {
    achievements.push({ id: 'pivot-master', confidence: pivotDetected.confidence });
  }

  // "Velocity King": 5x increase in shipping speed
  const velocityIncrease = await detectVelocityIncrease(data.historicalData);

  if (velocityIncrease >= 5) {
    achievements.push({ id: 'velocity-king', confidence: 0.9 });
  }

  return achievements.filter(a => a.confidence > 0.8);
}
```

## Quest Progress Auto-Update

Quests track progress automatically:

```typescript
export const updateQuestProgress = codeFunction({
  input: z.object({
    founderId: z.string(),
    actionType: z.string(),
    actionData: z.record(z.any())
  }),
  async execute({ founderId, actionType, actionData }) {
    // Get all active quests
    const activeQuests = await getActiveQuests(founderId);

    for (const quest of activeQuests) {
      // Check each objective
      for (let i = 0; i < quest.objectives.length; i++) {
        const objective = quest.objectives[i];

        if (objective.completed) continue;

        // Check if this action contributes to objective
        const contributes = await checkObjectiveProgress({
          objective,
          actionType,
          actionData
        });

        if (contributes.progress > 0) {
          // Update objective progress
          await updateObjectiveProgress({
            questId: quest.id,
            objectiveIndex: i,
            progress: contributes.progress
          });

          // Check if objective is complete
          if (contributes.complete) {
            await completeObjective({
              questId: quest.id,
              objectiveIndex: i
            });

            await notifyFounder(founderId, {
              type: 'objective-complete',
              questTitle: quest.title,
              objectiveDescription: objective.description
            });
          }
        }
      }

      // Check if entire quest is complete
      const allComplete = quest.objectives.every(o => o.completed);

      if (allComplete) {
        await completeQuest(quest.id);
        await awardQuestRewards(founderId, quest.rewards);
      }
    }

    return { updated: true };
  }
});
```

## Streak Tracking

Automatically maintain streak counters:

```typescript
export const recordDailyActivity = codeFunction({
  input: z.object({
    founderId: z.string(),
    activityType: z.string()
  }),
  async execute({ founderId, activityType }) {
    const today = new Date().toISOString().split('T')[0];

    // Record activity for today
    await logDailyActivity({
      founderId,
      date: today,
      activityType,
      timestamp: Date.now()
    });

    // Get activity types that count for streak
    const streakTypes = [
      'deployment',
      'coding',
      'customer-interaction',
      'content-published'
    ];

    if (streakTypes.includes(activityType)) {
      // Update streak
      await updateStreak(founderId, today);
    }

    return { recorded: true };
  }
});

async function updateStreak(founderId: string, today: string) {
  const founder = await getFounder(founderId);
  const yesterday = getYesterday(today);

  // Check if founder was active yesterday
  const yesterdayActivity = await getDailyActivity(founderId, yesterday);

  if (yesterdayActivity.length > 0 || founder.currentStreak === 0) {
    // Extend streak
    await incrementStreak(founderId);
  } else {
    // Streak broken - check for shield
    const hasShield = await checkStreakShield(founderId);

    if (hasShield) {
      await useStreakShield(founderId);
    } else {
      await resetStreak(founderId);
    }
  }
}
```

## Leaderboard Auto-Update

Leaderboards update without manual triggers:

```typescript
export const maintainLeaderboards = agenticFunction({
  schedule: 'every 10 minutes',
  async execute() {
    const leaderboardTypes = [
      'shipping-velocity',
      'revenue-growth',
      'customer-acquisition',
      'community-helpfulness',
      'streak-length'
    ];

    for (const type of leaderboardTypes) {
      await updateLeaderboard(type);
    }
  }
});

async function updateLeaderboard(type: string) {
  // Get all founders
  const founders = await getAllFounders();

  // Calculate scores
  const scores = await Promise.all(
    founders.map(async f => ({
      founderId: f.id,
      score: await calculateLeaderboardScore(f.id, type)
    }))
  );

  // Sort by score
  scores.sort((a, b) => b.score - a.score);

  // Save leaderboard
  await saveLeaderboard(type, scores);

  // Notify rank changes
  await notifyRankChanges(type, scores);
}
```

## Data Source Connectors

### Analytics Integration

```typescript
// Connect to analytics platform
export const syncAnalyticsData = agenticFunction({
  schedule: 'every hour',
  async execute() {
    const founders = await getFoundersWithAnalytics();

    for (const founder of founders) {
      const analytics = await fetchAnalytics({
        founderId: founder.id,
        source: founder.analyticsProvider,
        since: founder.lastAnalyticsSync
      });

      // Process metrics
      await processAnalytics({
        founderId: founder.id,
        data: analytics
      });

      // Check for milestones
      if (analytics.users.total >= 1000 && founder.metrics.users < 1000) {
        await unlockAchievement(founder.id, 'first-1k-users');
      }

      // Update founder metrics
      await updateFounderMetrics(founder.id, {
        users: analytics.users.total,
        activeUsers: analytics.users.active,
        sessions: analytics.sessions,
        lastAnalyticsSync: Date.now()
      });
    }
  }
});
```

### Payment Provider Integration

```typescript
// Stripe webhook handler
export const onStripeEvent = codeFunction({
  input: z.object({
    type: z.string(),
    data: z.record(z.any())
  }),
  async execute({ type, data }) {
    const founderId = await getFounderIdFromStripeCustomer(data.customer);

    switch (type) {
      case 'charge.succeeded':
        await handlePayment(founderId, data.amount);
        break;

      case 'customer.subscription.created':
        await handleNewSubscription(founderId, data);
        break;

      case 'invoice.payment_succeeded':
        await handleRecurringRevenue(founderId, data);
        break;
    }

    return { processed: true };
  }
});
```

## Privacy and Security

Auto-tracking respects privacy:

```typescript
export const configureTracking = codeFunction({
  input: z.object({
    founderId: z.string(),
    settings: z.object({
      trackDeployments: z.boolean(),
      trackRevenue: z.boolean(),
      trackCustomers: z.boolean(),
      shareWithCommunity: z.boolean(),
      leaderboardOptIn: z.boolean()
    })
  }),
  async execute({ founderId, settings }) {
    await updateFounderSettings(founderId, {
      tracking: settings
    });

    // Only track what founder allows
    await configureDataCollection(founderId, settings);

    return { updated: true };
  }
});
```

## Verification and Anti-Gaming

Prevent fake activity:

```typescript
export const verifyActivity = agenticFunction({
  schedule: 'hourly',
  async execute() {
    // Get suspicious activity
    const suspicious = await flagSuspiciousActivity();

    for (const activity of suspicious) {
      // Use AI to verify authenticity
      const verification = await verifyAuthenticity({
        founderId: activity.founderId,
        activityType: activity.type,
        activityData: activity.data,
        historicalPatterns: await getFounderPatterns(activity.founderId)
      });

      if (verification.isFake) {
        // Remove XP and achievements
        await revertActivity(activity.id);

        // Flag founder
        await flagFounder(activity.founderId, 'gaming-detected');

        // Notify founder
        await notifyFounder(activity.founderId, {
          type: 'activity-rejected',
          reason: verification.reason,
          activity: activity.type
        });
      }
    }
  }
});

async function flagSuspiciousActivity() {
  // Patterns that suggest gaming
  const rules = [
    'deployment-frequency-too-high', // 100 deploys in 1 hour
    'identical-commits', // Same commit repeated
    'impossible-timing', // Actions from multiple locations simultaneously
    'spike-in-activity', // 10x normal activity suddenly
    'low-quality-pattern' // Many trivial actions
  ];

  const suspicious = [];

  for (const rule of rules) {
    const flagged = await findActivitiesMatchingPattern(rule);
    suspicious.push(...flagged);
  }

  return suspicious;
}
```

## The Developer Experience

Founders don't think about tracking:

```
// Founder's perspective

1. Push code to git
   → Achievement unlocked: "Week Warrior" (7 day streak)
   → +50 XP

2. Customer pays invoice
   → Achievement unlocked: "First $1K MRR"
   → +500 XP
   → Climbed to #23 on revenue leaderboard

3. Deploy new feature
   → Quest progress: "Launch MVP" (4/5 complete)
   → +25 XP

All automatic. Zero manual input.
```

## Conclusion

Auto-tracking is what makes gamification actually work. The magic happens invisibly, tracking progress without adding cognitive load.

Agentic functions monitor everything, AI interprets significance, and founders just see rewards appear as they build.

In 2026, the best tracking is the tracking you never think about.

---

**Install startup.games** and let AI track your progress automatically.
